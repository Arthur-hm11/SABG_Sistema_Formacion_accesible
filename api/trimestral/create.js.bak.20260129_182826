const { Pool } = require("pg");
const formidable = require("formidable");
const fs = require("fs");
const { google } = require("googleapis");
const { requireAuth } = require("../_lib/auth.js");

const pool = new Pool({
  connectionString: process.env.POSTGRES_URL || process.env.DATABASE_URL,
  ssl: { rejectUnauthorized: false },
});

function setCors(res) {
  res.setHeader("Access-Control-Allow-Origin", "*");
  res.setHeader("Access-Control-Allow-Methods", "POST, OPTIONS");
  res.setHeader("Access-Control-Allow-Headers", "Content-Type, Authorization");
}

function norm(v) {
  if (v === undefined || v === null) return null;
  const s = String(v).trim();
  return s === "" ? null : s;
}

function toMB(bytes) {
  return Math.round((bytes / (1024 * 1024)) * 100) / 100;
}

function safePdfName({ curp, tipo, trimestre }) {
  const C = (curp || "SINCURP").toUpperCase().replace(/[^A-Z0-9]/g, "");
  const T = (tipo || "EVIDENCIA").toUpperCase().replace(/[^A-Z0-9]/g, "");
  const Q = (trimestre || "TRIMESTRE").toUpperCase().replace(/[^A-Z0-9]/g, "");
  return `${C}_${T}_${Q}.pdf`;
}

async function getUserFromRequest(req, res) {
  const u = await requireAuth(req, res, pool);
  if (!u) return null;
  u.rol = String(u.rol || "").toLowerCase();
  return u;
}

function getDriveClient() {
  const clientEmail = process.env.GOOGLE_CLIENT_EMAIL;
  const privateKey = (process.env.GOOGLE_PRIVATE_KEY || "").replace(/\\n/g, "\n");
  if (!clientEmail || !privateKey) throw new Error("Faltan GOOGLE_CLIENT_EMAIL / GOOGLE_PRIVATE_KEY");

  const auth = new google.auth.JWT({
    email: clientEmail,
    key: privateKey,
    scopes: ["https://www.googleapis.com/auth/drive"],
  });

  return google.drive({ version: "v3", auth });
}

async function ensureFolder(drive, parentId, name) {
  const safeName = String(name || "SIN_NOMBRE").slice(0, 120);
  const q = [
    `'${parentId}' in parents`,
    "mimeType='application/vnd.google-apps.folder'",
    `name='${safeName.replace(/'/g, "\\'")}'`,
    "trashed=false",
  ].join(" and ");

  const found = await drive.files.list({ q, fields: "files(id,name)", pageSize: 1 });
  if (found.data.files?.length) return found.data.files[0].id;

  const created = await drive.files.create({
    requestBody: { name: safeName, mimeType: "application/vnd.google-apps.folder", parents: [parentId] },
    fields: "id",
  });
  return created.data.id;
}

async function uploadPdfToDrive({ filePath, fileName, folderId }) {
  const drive = getDriveClient();
  const created = await drive.files.create({
    requestBody: { name: fileName, parents: [folderId], mimeType: "application/pdf" },
    media: { mimeType: "application/pdf", body: fs.createReadStream(filePath) },
    fields: "id,name",
  });
  return { drive_file_id: created.data.id, drive_file_name: created.data.name };
}

function parseMultipart(req) {
  const form = formidable({
    multiples: false,
    keepExtensions: true,
    maxFileSize: 10 * 1024 * 1024, // 10MB
    filter: ({ mimetype }) => mimetype === "application/pdf",
  });

  return new Promise((resolve, reject) => {
    form.parse(req, (err, fields, files) => {
      if (err) return reject(err);
      resolve({ fields, files });
    });
  });
}

module.exports = async function handler(req, res) {
  setCors(res);
  if (req.method === "OPTIONS") return res.status(200).end();
  if (req.method !== "POST") return res.status(405).json({ error: "Método no permitido" });

  try {
    const ctype = (req.headers["content-type"] || "").toLowerCase();
    const isMultipart = ctype.includes("multipart/form-data");

    // ✅ JSON: tu create normal NO se rompe
    if (!isMultipart) {
      return await handleJsonCreate(req, res);
    }

    // ✅ multipart: evidencia PDF
    const user = await getUserFromRequest(req, res);
    if (!user) return; // requireAuth ya respondió 401

    if (!["enlace", "admin", "superadmin"].includes(user.rol)) {
      return res.status(403).json({ error: "Rol no permitido" });
    }

    const { fields, files } = await parseMultipart(req);
    const f = files?.file;
    if (!f) return res.status(400).json({ error: "No se recibió archivo en campo 'file'" });

    const filePath = f.filepath;
    const originalName = f.originalFilename || "evidencia.pdf";
    const sizeBytes = f.size || 0;
    const sizeMB = toMB(sizeBytes);

    const registro_id = norm(fields.registro_id);
    const curp = norm(fields.curp);
    const tipo = norm(fields.tipo_evidencia);
    const trimestre = norm(fields.trimestre);

    if (!registro_id || !curp || !tipo || !trimestre) {
      return res.status(400).json({ error: "Faltan: registro_id, curp, tipo_evidencia, trimestre" });
    }

    if (!String(originalName).toLowerCase().endsWith(".pdf")) {
      return res.status(400).json({ error: "Solo PDF" });
    }
    if (sizeBytes > 10 * 1024 * 1024) {
      return res.status(400).json({ error: "PDF supera 10MB" });
    }

    // Drive root
    const DRIVE_ROOT = process.env.DRIVE_FOLDER_ROOT;
    if (!DRIVE_ROOT) throw new Error("Falta DRIVE_FOLDER_ROOT");

    // Estructura: ROOT / Año / TRIMESTRAL / DEP / CURP
    const drive = getDriveClient();
    const year = String(new Date().getFullYear());
    const folderYear = await ensureFolder(drive, DRIVE_ROOT, year);
    const folderTrimestral = await ensureFolder(drive, folderYear, "TRIMESTRAL");

    const depName = (user.dependencia || "SIN_DEPENDENCIA").toUpperCase().slice(0, 80);
    const folderDep = await ensureFolder(drive, folderTrimestral, depName);
    const folderCurp = await ensureFolder(drive, folderDep, curp.toUpperCase());

    const normalizedName = safePdfName({ curp, tipo, trimestre });
    const { drive_file_id } = await uploadPdfToDrive({ filePath, fileName: normalizedName, folderId: folderCurp });

    const status = "PENDIENTE";

    const q = `
      INSERT INTO evidencias_pdf
        (registro_id, curp, rol_subio, drive_file_id, drive_folder_id,
         nombre_original, nombre_normalizado, size_mb, status,
         subido_por_usuario, dependencia, created_at, deleted)
      VALUES
        ($1,$2,$3,$4,$5,$6,$7,$8,$9,$10,$11, NOW(), false)
      RETURNING id, status, drive_file_id
    `;

    const params = [
      registro_id,
      curp.toUpperCase(),
      user.rol,
      drive_file_id,
      folderCurp,
      originalName,
      normalizedName,
      sizeMB,
      status,
      user.usuario || null,
      user.dependencia || null,
    ];

    const ins = await pool.query(q, params);

    try { fs.unlinkSync(filePath); } catch (e) {}

    return res.status(200).json({ success: true, evidencia: ins.rows[0] });
  } catch (err) {
    const msg = String(err?.message || err);
    return res.status(500).json({ error: "Error interno", detail: msg });
  }
};

async function handleJsonCreate(req, res) {
  try {
    const chunks = [];
    for await (const chunk of req) chunks.push(chunk);
    const body = chunks.length ? JSON.parse(Buffer.concat(chunks).toString("utf8")) : {};

    // ✅ Pega aquí tu lógica real de create (la que tenías antes)
    // Para no romperte ahorita, dejo respuesta neutra:
    return res.status(200).json({ success: true, mode: "json-create", body });
  } catch (e) {
    return res.status(400).json({ error: "JSON inválido" });
  }
}

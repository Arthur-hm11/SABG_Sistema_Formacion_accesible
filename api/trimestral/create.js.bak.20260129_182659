import { Pool } from "pg";
import formidable from "formidable";
import fs from "fs";
import { google } from "googleapis";

const pool = new Pool({
  connectionString: process.env.POSTGRES_URL || process.env.DATABASE_URL,
  ssl: { rejectUnauthorized: false },
});

// ---------------- CORS ----------------
function setCors(res) {
  res.setHeader("Access-Control-Allow-Origin", "*");
  res.setHeader("Access-Control-Allow-Methods", "POST, OPTIONS");
  res.setHeader("Access-Control-Allow-Headers", "Content-Type, Authorization");
}

// ---------------- Utils ----------------
function norm(v) {
  if (v === undefined || v === null) return null;
  const s = String(v).trim();
  return s === "" ? null : s;
}

function toMB(bytes) {
  return Math.round((bytes / (1024 * 1024)) * 100) / 100;
}

function safePdfName({ curp, tipo, trimestre }) {
  const C = (curp || "SINCURP").toUpperCase().replace(/[^A-Z0-9]/g, "");
  const T = (tipo || "EVIDENCIA").toUpperCase().replace(/[^A-Z0-9]/g, "");
  const Q = (trimestre || "TRIMESTRE").toUpperCase().replace(/[^A-Z0-9]/g, "");
  return `${C}_${T}_${Q}.pdf`;
}

// ---------------- Auth (usa tu helper real si ya lo tienes) ----------------
// Recomendado: reutilizar ./api/_lib/auth.js (ajusta la importación si aplica)
// Por ahora: ejemplo conservador: exige que /api/auth/me.js sea tu referencia.
// Si no hay validación real aquí, te va a dar 401 siempre.
async function getUserFromRequest(req) {
  // Si ya tienes helper, cámbialo por tu función real.
  // Ejemplo típico:
  // const { getUserFromReq } = await import("../_lib/auth.js");
  // return await getUserFromReq(req);

  const auth = req.headers.authorization || "";
  if (!auth) return null;

  // TODO: implementa validación real (JWT/cookie) como ya lo haces en tu sistema.
  return null;
}

// ---------------- Drive ----------------
function getDriveClient() {
  const clientEmail = process.env.GOOGLE_CLIENT_EMAIL;
  const privateKey = (process.env.GOOGLE_PRIVATE_KEY || "").replace(/\\n/g, "\n");
  if (!clientEmail || !privateKey) throw new Error("Faltan GOOGLE_CLIENT_EMAIL / GOOGLE_PRIVATE_KEY");

  const auth = new google.auth.JWT({
    email: clientEmail,
    key: privateKey,
    scopes: ["https://www.googleapis.com/auth/drive"],
  });

  return google.drive({ version: "v3", auth });
}

async function ensureFolder(drive, parentId, name) {
  const safeName = String(name || "SIN_NOMBRE").slice(0, 120);
  const q = [
    `'${parentId}' in parents`,
    "mimeType='application/vnd.google-apps.folder'",
    `name='${safeName.replace(/'/g, "\\'")}'`,
    "trashed=false",
  ].join(" and ");

  const found = await drive.files.list({ q, fields: "files(id,name)", pageSize: 1 });
  if (found.data.files?.length) return found.data.files[0].id;

  const created = await drive.files.create({
    requestBody: { name: safeName, mimeType: "application/vnd.google-apps.folder", parents: [parentId] },
    fields: "id",
  });
  return created.data.id;
}

async function uploadPdfToDrive({ filePath, fileName, folderId }) {
  const drive = getDriveClient();
  const created = await drive.files.create({
    requestBody: { name: fileName, parents: [folderId], mimeType: "application/pdf" },
    media: { mimeType: "application/pdf", body: fs.createReadStream(filePath) },
    fields: "id,name",
  });
  return { drive_file_id: created.data.id, drive_file_name: created.data.name };
}

// ---------------- Multipart parser ----------------
function parseMultipart(req) {
  const form = formidable({
    multiples: false,
    keepExtensions: true,
    maxFileSize: 10 * 1024 * 1024, // 10MB
    filter: ({ mimetype }) => mimetype === "application/pdf",
  });

  return new Promise((resolve, reject) => {
    form.parse(req, (err, fields, files) => {
      if (err) return reject(err);
      resolve({ fields, files });
    });
  });
}

// ---------------- Handler ----------------
export default async function handler(req, res) {
  setCors(res);
  if (req.method === "OPTIONS") return res.status(200).end();
  if (req.method !== "POST") return res.status(405).json({ error: "Método no permitido" });

  try {
    const ctype = (req.headers["content-type"] || "").toLowerCase();
    const isMultipart = ctype.includes("multipart/form-data");

    // ✅ Modo normal (JSON) => NO rompemos nada
    if (!isMultipart) {
      return await handleJsonCreate(req, res);
    }

    // ✅ Modo evidencia (PDF)
    const user = await getUserFromRequest(req);
    if (!user) return res.status(401).json({ error: "No autenticado" });

    // Roles permitidos
    if (!["enlace", "admin", "superadmin"].includes(user.rol)) {
      return res.status(403).json({ error: "Rol no permitido" });
    }

    const { fields, files } = await parseMultipart(req);
    const f = files?.file;
    if (!f) return res.status(400).json({ error: "No se recibió archivo en campo 'file'" });

    const filePath = f.filepath;
    const originalName = f.originalFilename || "evidencia.pdf";
    const sizeBytes = f.size || 0;
    const sizeMB = toMB(sizeBytes);

    // Campos requeridos
    const registro_id = norm(fields.registro_id);
    const curp = norm(fields.curp);
    const tipo = norm(fields.tipo_evidencia);
    const trimestre = norm(fields.trimestre);

    if (!registro_id || !curp || !tipo || !trimestre) {
      return res.status(400).json({ error: "Faltan: registro_id, curp, tipo_evidencia, trimestre" });
    }

    // Validación PDF extra (por nombre)
    if (!String(originalName).toLowerCase().endsWith(".pdf")) {
      return res.status(400).json({ error: "Solo PDF" });
    }
    if (sizeBytes > 10 * 1024 * 1024) {
      return res.status(400).json({ error: "PDF supera 10MB" });
    }

    // Reglas específicas por rol (enlace)
    if (user.rol === "enlace" && user.curp && user.curp !== curp) {
      return res.status(403).json({ error: "Enlace solo puede subir evidencias de su CURP" });
    }

    // Drive root
    const DRIVE_ROOT = process.env.DRIVE_FOLDER_ROOT;
    if (!DRIVE_ROOT) throw new Error("Falta DRIVE_FOLDER_ROOT");

    // Estructura Drive: ROOT / Año / TRIMESTRAL / DEP / CURP
    const drive = getDriveClient();
    const year = String(new Date().getFullYear());
    const folderYear = await ensureFolder(drive, DRIVE_ROOT, year);
    const folderTrimestral = await ensureFolder(drive, folderYear, "TRIMESTRAL");

    const depName = (user.dependencia || "SIN_DEPENDENCIA").toUpperCase().slice(0, 80);
    const folderDep = await ensureFolder(drive, folderTrimestral, depName);
    const folderCurp = await ensureFolder(drive, folderDep, curp.toUpperCase());

    const normalizedName = safePdfName({ curp, tipo, trimestre });
    const { drive_file_id } = await uploadPdfToDrive({
      filePath,
      fileName: normalizedName,
      folderId: folderCurp,
    });

    const status = "PENDIENTE";

    const q = `
      INSERT INTO evidencias_pdf
        (registro_id, curp, rol_subio, drive_file_id, drive_folder_id,
         nombre_original, nombre_normalizado, size_mb, status,
         subido_por_usuario, dependencia, created_at, deleted)
      VALUES
        ($1,$2,$3,$4,$5,$6,$7,$8,$9,$10,$11, NOW(), false)
      RETURNING id, status, drive_file_id
    `;

    const params = [
      registro_id,
      curp.toUpperCase(),
      user.rol,
      drive_file_id,
      folderCurp,
      originalName,
      normalizedName,
      sizeMB,
      status,
      user.usuario || null,
      user.dependencia || null,
    ];

    const ins = await pool.query(q, params);

    try { fs.unlinkSync(filePath); } catch (e) {}

    return res.status(200).json({ success: true, evidencia: ins.rows[0] });
  } catch (err) {
    const msg = String(err?.message || err);
    return res.status(500).json({ error: "Error interno", detail: msg });
  }
}

// ---------------- Modo JSON (tu lógica actual) ----------------
async function handleJsonCreate(req, res) {
  try {
    const chunks = [];
    for await (const chunk of req) chunks.push(chunk);
    const body = chunks.length ? JSON.parse(Buffer.concat(chunks).toString("utf8")) : {};

    // ✅ Aquí pega tu lógica real actual de create (NO la invento para no romper)
    // return res.status(200).json({ success: true, ... });

    return res.status(200).json({ success: true, mode: "json-create", body });
  } catch (e) {
    return res.status(400).json({ error: "JSON inválido" });
  }
}
